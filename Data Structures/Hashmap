//  Name: Bhawana
//  Email_id: bhawana053@gmail.com

//  Hashmap Implementation: This program focuses on how insertion, searching and deletion works in a hashmap internally. 

	#include <string>
	#include<iostream>
	using namespace std;
   
	// user can specify the data type(V) of value 
	template <typename V>
	class MapNode {
		public:
			string key;
			V value;
			MapNode* next;

			MapNode(string key, V value) {
				this->key = key;
				this->value = value;
				next = NULL;
			}

			~MapNode() {
				delete next;
			}
	};

	template <typename V>
	class OurMap {

	//  MapNode Object to hold key-value pairs
		MapNode<V>** buckets;
		
	//gives the size of hashmap (number of key-value pair present in the map)
		int count; 
		
	 //define capacity of buckets
		int num_buckets;

		public:
		
		OurMap() {
		 //initially no key value pair is present
			count = 0;
			
			// creating a Buckets of size 5 ( you can change the size)
			num_buckets = 5; 
			
			buckets = new MapNode<V>*[num_buckets]; 

			for (int i = 0; i < num_buckets; i++) {
			  //Dynamically initializing buckets to NULL 
				buckets[i] = NULL;                  
			}
		}

		~OurMap() {
		// Destructor for freeing the memory after we are done 
		
			for (int i = 0; i < num_buckets; i++) { 
				delete buckets[i];
			}
			delete [] buckets;
		}

		//function to return size of our hashmap
		int size() {   
			return count;
		}
		private:
		//function to find bucket_Index for a key
		int getbucket_Index(string key) {   
			int hash_code = 0;

			
			//for any number/string of the form "abc" its hash_code is calculated using formula : a*p^2 + b*p+ c*p^0. 
			//where p is any prime number. (prime number is chosen so as to have a good distribution)
			//to avoid overflow in hash_code we will use compression function which is simply (a*p^2 + b*p+ c*p^0)%bucket size.
			//And we know that (a*b*c)%n =((a%n)*(b%n)*(c%n))%n;
			 
			
			int current_coeff = 1;
			for (int i = key.length() - 1; i >= 0; i--) {
				hash_code += key[i] * current_coeff;
				
				//compress so that hash_code may not exceed range of int
				hash_code = hash_code % num_buckets; 
				
				//37 is the chosen prime number here. u can choose any other 
				
				current_coeff *= 37;              
				//compress  so that current_coeff may not exceed range of int
				
				current_coeff = current_coeff % num_buckets; 
			}
			 //compression function so that result may not exceed range of int
			return hash_code % num_buckets;   
		}
		public:

		//function to get value of a key
		V getValue(string key) {       
			int bucket_Index = getbucket_Index(key);
			MapNode<V>* head = buckets[bucket_Index];
			
			while (head != NULL) {
				if (head->key == key) {
					return head->value;
				}
				head = head->next;
			}
			
			return 0;
		}
		 //function to insert a key-value pair
		void insert(string key, V value) {       
			int bucket_Index = getbucket_Index( key);
			MapNode<V>* head = buckets[bucket_Index];
			while (head != NULL) {
				if (head->key == key) {
					head->value = value;
					return;
				}
				head = head->next;
			}
			head = buckets[bucket_Index];
			MapNode<V>* node = new MapNode<V>(key, value);
			node->next = head;
			buckets[bucket_Index] = node;
			
			//increment count after inserting a key-value pair
			count++;                      
		}
		
		//function for removing a key and returning its value
		V remove(string key) {                   
			int bucket_Index = getbucket_Index(
				key);
			MapNode<V>* head = buckets[bucket_Index]; 
			MapNode<V>* prev = NULL;
			while (head != NULL) {
			
	    //move head until required key is not found		
					if (head->key == key) {               
					if (prev == NULL) {
						buckets[bucket_Index] = head->next;
					} else {
						prev->next = head->next;
					}
					V value = head->value;
					head->next = NULL;
					delete head;
		  //decrement size of hash map	
			count--;       
					return value;
				}
				prev = head;
				head = head->next;
			}
			return 0;
		}

	};
	int main()
	{
		
		OurMap<int> mp;
				 mp.insert("abc",1);
				 mp.insert("def",2);
				 mp.insert("xyz",67);
				cout<<"size of map is "<<mp.size()<<"\n";
				cout<<"value of string abc is "<<mp.getValue("abc")<<"\n";
				cout<<"Removing key abc from the map and printing value of removed key "<<mp.remove("abc")<<"\n";
				cout<<"After removal size of map is "<<mp.size();
				
	}
	
	
	// Time Complexity :
	// Insertion : for inserting a key value pair, first required bucket index is to be found which takes O(l) time 
	// where l is length of key. After getting the bucket_Index you check whether a key already exists if so you update the value, 
	// otherwise u keep on moving till head is NULL and insert the key, this take O(n) time in worst case.
	// So total of O(nl) time for insertion.
	// Since n>>l l can be neglected.
	// Therefore, for insertion time complexity is O(n)
	
	// Removal: We need to find bucket_index of key which is to be deleted, it takes 0(l) time.
	// Iterate through the bucket_index to find the key ( O(n) time ) and delete the key 0(1).
	// Total complexity O(nl). 
	// Since n>>l l can be neglected.
	// Therefore, for deletion time complexity is O(n).
	
	// Searching: Find the bucket_index of the key iterate through the required bucket[i] and
	// stop as soon as key is found.
	// Time Complexity : O(n)
	
	//Space Complexity : O(n) where n is size of hashmap
